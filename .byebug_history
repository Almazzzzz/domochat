continue
DateTime.now
 @poll.start
@poll.finish
continue
update_option.poll_option = option[1]
update_option = Option.where(:id => option[0].to_i).first
update_option = Option.where(:id => option[0].to_i)
option[1]
continue
reload
option[1]
update_option.poll_option = option[1]
update_option.poll_option
update_option = Option.where(:id => option[0])
Option.where(:id => option[0])
option
 params[:options]
continue
@poll.options.empty?
@poll.options.count
continue
ActiveRecord::Associations::CollectionProxy methods
c=c.pluck(:id)
o.1
o=@poll.options
@poll.options
option[:poll_option]
option
params[:options]
continue
@poll.options.count
continue
@poll.options.count
continue
@poll.options.count
continue
vote
continue
vote
continue
vote
continue
vote
continue
vote
continue
option[0]
option[1]
option
params[:options]
continue
pol = Poll.where(:id => option.poll_id)
option = Option.where(:id => vote.option_id)
continue
c=c.to_i
c = options["poll_option"]
options
options{"poll_option"}
options
exit
options
options = options.to_h
(param[:poll_options]
options(param[:poll_options])
options(param[:poll_options]
options.class
options{"poll_options"}
options{poll_options}
options{:poll_options}
options[:poll_options]
options
exit
options
params[:options]
params[options]
options
exit
MainMailer.news_email(@users, @email.subject, @email.body)
@email.body
@email.subject
@users
